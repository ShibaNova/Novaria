// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

import "./interfaces/IFleet.sol";
import "./interfaces/IShadowPool.sol";
import "./interfaces/IMap.sol";
import "./libs/ShibaBEP20.sol";
import "./libs/SafeBEP20.sol";
import "./libs/Editor.sol";
import "./libs/Helper.sol";

/*
 This contract creates stars and jackpots, which are locations that 
 allow players to mine NOVA. Contract manages NOVA, harvesting, 
 refining, and transferring unrefined NOVA.
*/

/* TO-DO
- pause function
*/

contract PlaceManager is Editor {
    using SafeBEP20 for ShibaBEP20;
    
    constructor (
        IMap _map,
        ShibaBEP20 _nova,
       // IFleet _fleet,
        IShadowPool _shadowPool
    ) {
        Map = _map;
        ShadowPool = _shadowPool;
        Nova = _nova;
       // Fleet = _fleet;
        rewardsMod = 1;
        previousBalance = 0;
        rewardsTimer = 0;
        rewardsDelay = 14400;
        // setInitial();
    }

    IMap public Map;
    IShadowPool public ShadowPool;
    ShibaBEP20 public Nova; // NOVA Token
    IFleet public Fleet; // Fleet Contract
    uint public rewardsMod; // = x/100, the higher the number the more rewards sent to this contract
    uint previousBalance; // contract balance before added Nova
    uint rewardsTimer; // Rewards can only be pulled from shadow pool every 4 hours?
    uint rewardsDelay;
    bool setup; // ensures setInitial only happens once
    mapping (uint => bool) isPaused; // can pause nova harvesting for jackpots

    Jackpot[] public jackpots; // ordered list of jackpot planets
    mapping (uint => mapping (uint => uint)) jackpotCoords; // assigns coords to jackpot ID
    Star[] public stars; // ordered list of stars
    mapping (uint => mapping (uint => uint)) starCoords; // assigns coords to star ID

    uint public totalLuminosity; // sum of the luminosity of all stars, denominator of NOVA allocation
    mapping (uint => uint) public jackpotTotal; // sum of jackpot starDist for a given star, denominator of NOVA allocaiotn
    // User => star => unrefinedNova. Player's current UNova and where is comes from
    mapping(address => mapping(uint => uint)) userUNova;
  
    struct Jackpot {
        uint coordX;
        uint coordY;
        uint starDist; // distance from star determines numerator NOVA allocation between planets of the same star
        uint availableNova;
        uint starId;
    }

    // if a star doesn't have a rewards planet, the star will collect nova that can't be used
    // during allocation, check if a star has a planet
    // rename size to luminosity
    struct Star {
        uint coordX;
        uint coordY;
        uint luminosity; // luminosity determines numerator of NOVA allocation between stars
        uint novaBalance;
        uint unrefinedBalance;
    }

    event NewMap(address _new);
    event NewShadowPool(address _new);
    event NewFleet(address _new);
    event NewNova(address _new);
    event NewRewardsMod(uint _new);
    event UNovaTransferred(address _from, address _to, uint _amount);
    event NovaRefined(address _player, uint _amount);
    event UNovaHarvested(address _player, uint _amount);
    event NewJackpot(uint _star, uint _x, uint _y);
    event NewStar(uint _x, uint _y);

    // transfers NOVA from this contract to the owner, used for contract maintenance 
    function withdrawNOVA(uint _amount) external onlyOwner {
        Nova.safeTransfer(msg.sender, _amount);
    }

    //eventually will be generated by exploring - connect to Map, Editor
    function createStar (uint _x, uint _y) public  {
        // add requirement for duplicates
        // add requirements for placement parameters
        uint _luminosity = Helper.createRandomNumber(10);
        _createStar(_luminosity, _x, _y);
    }

    function _createStar (uint _luminosity, uint _x, uint _y) internal {
        // add requirement for duplicates
        // add requirements for placement parameters
        uint _id = stars.length;
        stars.push(Star(_x, _y, _luminosity, 0, 0));
        starCoords[_x][_y] = _id;
        totalLuminosity += _luminosity;
        emit NewStar(_x, _y);
    }
    //eventually will be generated by exploring - connect to Map, Editor
    function createJackpot(uint _starId, uint _x, uint _y) public  {
        // add requirement for duplicates
        // add requirements for placement parameters
        uint starX = stars[_starId].coordX;
        uint starY = stars[_starId].coordY;
        uint _dist = Helper.getDistance(starX*10, starY*10, _x*10, _y*10);
        _createJackpot(_dist, _starId, _x, _y);
    }

    function _createJackpot(uint _dist, uint _starId, uint _x, uint _y) internal {
        // add requirement for duplicates
        // add requirements for placement parameters
        uint _id = jackpots.length;
        jackpots.push(Jackpot(_x, _y, _dist, 0, _starId));
        jackpotCoords[_x][_y] = _id;
        jackpotTotal[_starId] = jackpotTotal[_starId] + _dist;
        emit NewJackpot(_starId, _x, _y);
    }

    function getStarId(uint _x, uint _y) external view returns (uint) {
        return starCoords[_x][_y];
    }

    // set this to internal at some point, triggered by requestNova
    function allocateNova() public {
        uint _amount = Nova.balanceOf(address(this)) - previousBalance;
        require(_amount > 0, "PLACEMANAGER: no Nova to allocate");
            for (uint i = 0; i < stars.length; i++) {
                uint _allocation = (_amount * stars[i].luminosity / totalLuminosity);
                stars[i].novaBalance = stars[i].novaBalance + _allocation;
                for (uint j = 0; j < jackpots.length; j++) {
                    if (jackpots[j].starId == i) {
                        uint numerator = _allocation * jackpots[j].starDist;
                        uint denominator = jackpotTotal[i];
                        jackpots[j].availableNova = (numerator > 0 ?
                            jackpots[j].availableNova + (numerator / denominator) : 0);
                            
                    }
                } 
            }
        previousBalance = Nova.balanceOf(address(this));
    }

    // Pulls nova from the shadow pool, eventually internal function
    function requestNova() external onlyOwner{
        if (block.timestamp >= rewardsTimer) {
            ShadowPool.replenishPlace(address(this), rewardsMod);
            rewardsTimer = block.timestamp + rewardsDelay;
            allocateNova();
        }
    }

    // function to set ID = 0 of sun and jackpot to coords 0,0 with 0 rewards. 
    // this is required for contract logic to work
    function setInitial() public onlyOwner {
        require(setup != true, "Initial star and jackpot already created");
        setup = true;
        _createStar(0, 0, 0);
        _createJackpot(0, 0, 0, 0);
    }

    function getJackpotNova(uint _x, uint _y) external view returns (uint) {
         uint _jackpotId = jackpotCoords[_x][_y];
         return jackpots[_jackpotId].availableNova;
    }

    function harvest(uint _x, uint _y) external {
        address _sender = msg.sender;
        uint _playerX;
        uint _playerY;
        (_playerX,) = Map.getPlayerLocation(_sender);
        (,_playerY) = Map.getPlayerLocation(_sender);
        require(_playerX == _x && _playerY == _y, "PLACEMANAGER: Fleet is not here");
        require(jackpotCoords[_x][_y] != 0, "PLACEMANAGER: No jackpot planet located here");
        // uint maxHarvest = Fleet.getNovaCapacity[_player] - getUserUNova(_sender);
        //link to fleets, will have to edit maxHarvest with above
        uint maxHarvest = 10**18;
        uint _jackpotId = jackpotCoords[_x][_y];
        require(isPaused[_jackpotId] != true, "PLACEMANAGER: Jackpot is paused");
        uint _starId = jackpots[_jackpotId].starId;
        require(jackpots[_jackpotId].availableNova > 0, "PLACEMANAGER: No NOVA available");
        uint _amount = (jackpots[_jackpotId].availableNova < maxHarvest 
                        ? jackpots[_jackpotId].availableNova : maxHarvest);
        jackpots[_jackpotId].availableNova = jackpots[_jackpotId].availableNova - _amount;

        stars[_starId].unrefinedBalance = stars[_starId].unrefinedBalance + _amount;
        require(stars[_starId].unrefinedBalance <= stars[_starId].novaBalance,
                        "PLACEMANAGER: Star does not have enough nova");

        userUNova[_sender][_starId] += _amount;
        emit UNovaHarvested(_sender, _amount);
    }

    function refine() external {
        address sender = msg.sender;
        uint fleetX;
        uint fleetY;
        (fleetX, fleetY) = Map.getPlayerLocation(sender);
        // PROBLEM: does not work?
        require(Map.isRefinery(fleetX, fleetY) == true, "PLACEMANAGER: Fleet not at a refinery");
        require(getUserUNova(sender) > 0, "PLACEMANAGER: Player has no unrefined Nova");
        uint totalUnAmount;
        for (uint i=0; i < stars.length; i++) {
            uint unAmount = userUNova[sender][i];
            userUNova[sender][i] = 0;
            stars[i].novaBalance = stars[i].novaBalance - unAmount;
            stars[i].unrefinedBalance = stars[i].unrefinedBalance - unAmount;
            totalUnAmount = totalUnAmount + unAmount;
        }
        Nova.safeTransfer(sender, totalUnAmount);
        previousBalance = previousBalance - totalUnAmount;
        emit NovaRefined(sender, totalUnAmount);
    }

    // remember to set to onlyEditor
    // Allows players to take unrefined nova from other players
    function transferUNova(address _sender, address _receiver, uint _percent) external {
        //uint _amount = ((getUserUNova(_sender) * _percent / 100) <= (Fleet.getNovaCapacity[_player] - getUserUNova(_sender)) ? (getUserUNova(_sender) * _percent / 100) : (Fleet.getNovaCapacity[_player] - getUserUNova(_sender)));
        // replace _amount with previous line when we have fleet data
        uint _amount = (getUserUNova(_sender) * _percent / 100);
        uint _transferred; 
        for (uint i=0; i < stars.length; i++) {
            if (_amount > userUNova[_sender][i]) {
                uint _transfer = userUNova[_sender][i];
                _amount = _amount - _transfer;
                userUNova[_sender][i] = userUNova[_sender][i] - _transfer;
                userUNova[_receiver][i] = userUNova[_receiver][i] + _transfer;
                _transferred = _transferred + _transfer;
            } else if (userUNova[_sender][i] >= _amount) {
                uint _transfer = _amount;
                _amount = 0;
                userUNova[_sender][i] = userUNova[_sender][i] - _transfer;
                userUNova[_receiver][i] = userUNova[_receiver][i] + _transfer;
                _transferred = _transferred + _transfer;
                
            } 
        }
        emit UNovaTransferred(_sender, _receiver, _transferred);
    }

    function getUserUNova(address _player) public view returns(uint){
        uint currentUNova;
        for (uint i=0; i < stars.length; i++) {
            currentUNova = currentUNova + userUNova[_player][i];
        }
        return currentUNova;
    }

    // Functions to setup contract interfaces
    function setMap(address _new) external onlyOwner {
        require(address(0) != _new);
        Map = IMap(_new);
        emit NewMap(_new);
    }
    function setShadowPool(address _new) external onlyOwner {
        require(address(0) != _new);
        ShadowPool = IShadowPool(_new);
        emit NewShadowPool(_new);
    }
    function setFleet(address _new) external onlyOwner {
        require(address(0) != _new);
        Fleet = IFleet(_new); 
        emit NewFleet(_new);
    }
    function setNova(address _new) external onlyOwner {
        require(address(0) != _new);
        Nova = ShibaBEP20(_new);
        emit NewNova(_new);
    }
    // Maintenance functions
    function setRewardsMod(uint _new) external onlyOwner {
        require(_new <= 100, "PLACEMANAGER: must be <= 100");
        rewardsMod = _new; // can set to 0 to turn off Nova incoming to contract
        emit NewRewardsMod(_new);
    }
    function setRewardsTimer(uint _new) external onlyOwner {
        rewardsTimer = _new;
    }
    function setRewardsDelay(uint _new) external onlyOwner {
        rewardsDelay = _new;
    }
    // Pause unrefined nova mining at a jackpot planet
    function setPaused(uint _id,bool _isPaused) external onlyOwner{
        isPaused[_id] = _isPaused;
    }
}